<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>light_direction</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="light_direction_files/libs/clipboard/clipboard.min.js"></script>
<script src="light_direction_files/libs/quarto-html/quarto.js"></script>
<script src="light_direction_files/libs/quarto-html/popper.min.js"></script>
<script src="light_direction_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="light_direction_files/libs/quarto-html/anchor.min.js"></script>
<link href="light_direction_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="light_direction_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="light_direction_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="light_direction_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="light_direction_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="échantillonage-de-la-lumière" class="level2">
<h2 class="anchored" data-anchor-id="échantillonage-de-la-lumière">1. Échantillonage de la lumière</h2>
<p>Comme on a sait, afin d’échantillonage un rayon de lumière, il faut:</p>
<ul>
<li>Échantionner un point de départ</li>
<li>Échantionner la direction de la lumière</li>
<li>Calculer l’énergie lumineuse de ce rayon par BRDF</li>
</ul>
<p>On a déjà vu le façcon pour calculer l’énergie lumineuse de rayon dans la partie avante. Maintenant, je vais vous montrer le pipeline pour échantionner le point de départ et la direction de la lumière.</p>
<p>Dans la simulation d’interception de la lumière, il y a deux temps où on doit faire l’échantillonage d’un nouveau rayon:</p>
<ul>
<li>Le rayon d’éclairement qui part d’un source de la lumière</li>
<li>Le rayon de réflexion qui part d’un surface</li>
</ul>
<p>Pour le rayon d’éclairement, on va avoir des différents stratégies d’échantillonnage correspondant les formes de la source de lumière. Pourtant, dans notre projet, par définir la forme de la source de lumière sous la forme un tableau des triangles, et considèrer chaque triangle est un source de lumière, on peut répresenter tous les types de lumière.</p>
<p>D’autre part, les surfaces des objets dans la scène sont aussi représenté sous la forme d’un triangle. Alors, dans notre projet, on n’considère que l’échantillonage le rayon sur un triangle.</p>
<section id="échantionner-un-point-de-départ" class="level3">
<h3 class="anchored" data-anchor-id="échantionner-un-point-de-départ">1.1. Échantionner un point de départ</h3>
<p style="text-align: center">
<img src="images/barycentric.png" width="300" style="display:block; margin: auto"> <br> Figure 1: Les coordonnées barycentriques
</p>
<p>Les coordonnées d’un point d’un triangle sont représentées par les coordonnées barycentrique:</p>
<p><span class="math display">\[P = uA + vB + wC\]</span></p>
<p>avec:</p>
<ul>
<li>A,B et C sont des coordonnées des coins de triangle</li>
<li>u, v et w sont calculer par ces formules: <span class="math display">\[ u = \frac{Area_{CAP}}{Area_{ABC}} \]</span> <span class="math display">\[ v = \frac{Area_{ABP}}{Area_{ABC}} \]</span> <span class="math display">\[ w = \frac{Area_{BCP}}{Area_{ABC}} \]</span></li>
</ul>
<p>Donc, en échantionnant aléatoirement trois valeurs u,v et w, on va obtenir un point sur le triangle. Les contraints de ces trois valeurs:</p>
<p><span class="math display">\[ u + v + w = 1 \]</span> <span class="math display">\[ 0 \leq u, v, w \leq 1 \]</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// sample point on the triangle</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>SurfaceInfo Triangle<span class="op">::</span>samplePoint<span class="op">(</span>Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  SurfaceInfo ret<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  Vec3ui vidx <span class="op">=</span> getIndices<span class="op">();</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  Vec3f p1 <span class="op">=</span> getVertexPosition<span class="op">(</span>vidx<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  Vec3f p2 <span class="op">=</span> getVertexPosition<span class="op">(</span>vidx<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  Vec3f p3 <span class="op">=</span> getVertexPosition<span class="op">(</span>vidx<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// sample point on triangle</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  Vec2f uv <span class="op">=</span> sampler<span class="op">.</span>getNext2D<span class="op">();</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> su0 <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(</span>uv<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  Vec2f barycentric <span class="op">=</span> Vec2f<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span> <span class="op">-</span> su0<span class="op">,</span> uv<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">*</span> su0<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  ret<span class="op">.</span>position <span class="op">=</span> <span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span> <span class="op">-</span> barycentric<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> barycentric<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">*</span> p1 <span class="op">+</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                 barycentric<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">*</span> p2 <span class="op">+</span> barycentric<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">*</span> p3<span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// compute normal</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  ret<span class="op">.</span>shadingNormal <span class="op">=</span> computeShadingNormal<span class="op">(</span>barycentric<span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// compute dpdu, dpdv</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  orthonormalBasis<span class="op">(</span>ret<span class="op">.</span>shadingNormal<span class="op">,</span> ret<span class="op">.</span>dpdu<span class="op">,</span> ret<span class="op">.</span>dpdv<span class="op">);</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  ret<span class="op">.</span>barycentric <span class="op">=</span> barycentric<span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// compute pdf</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  pdf <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span> <span class="op">/</span> surfaceArea<span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="échantionner-une-direction-de-la-lumière" class="level3">
<h3 class="anchored" data-anchor-id="échantionner-une-direction-de-la-lumière">1.2. Échantionner une direction de la lumière</h3>
<p>Comme on a sait, toutes les directions des rayons qui part d’un surface sont distribué sur un hemisphere. Alors, pour échantilloner une direction, d’abord, on va échantionner une direction d’un hemisphère supérieur. Ce hemispheère a la centre situé au (0,0,0) et le rayon est 1. Ensuite, on va appliquer une transformation de l’axe pour transformer l’axe Y (0,1,0) du hemisphere à la normal du surface.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    Vec3f sampleDirection<span class="op">(</span><span class="at">const</span> SurfaceInfo <span class="op">&amp;</span>surfInfo<span class="op">,</span> Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        Vec3f dir <span class="op">=</span> sampleCosineHemisphere<span class="op">(</span>sampler<span class="op">.</span>getNext2D<span class="op">(),</span> pdf<span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        Vec3f wo <span class="op">=</span> localToWorld<span class="op">(</span>dir<span class="op">,</span> surfInfo<span class="op">.</span>dpdu<span class="op">,</span> surfInfo<span class="op">.</span>shadingNormal<span class="op">,</span> surfInfo<span class="op">.</span>dpdv<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// transform direction from local to world</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> wo<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Échantillonner une direction du hemisphère supérieur</strong></p>
<p style="text-align: center">
<img src="images/hemisphere.png" width="400" style="display:block; margin: auto"> <br> Figure 2: Échantillonage d’une direction de hemisphere
</p>
<p>Une direction de hemisphère est représentée par les deux angles <span class="math inline">\(\theta\)</span> et <span class="math inline">\(\phi\)</span></p>
<ul>
<li><span class="math inline">\(\phi\)</span> est l’angle entre la projection de la direction sur la surface et l’axe X, entre <span class="math inline">\([ 0, 2\pi ]\)</span></li>
<li><span class="math inline">\(\theta\)</span> est l’angle entre la direction et l’axe Z, entre <span class="math inline">\([-\frac{\pi}{2}, \frac{\pi}{2}]\)</span></li>
</ul>
<p>En échantillonnant aléatoirement ces deux angles, on va obtenir une direction.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Vec3f sampleCosineHemisphere<span class="op">(</span>Vec2f uv<span class="op">,</span> <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> theta <span class="op">=</span> <span class="fl">0.5</span><span class="bu">f</span> <span class="op">*</span> <span class="bu">std::</span>acos<span class="op">(</span><span class="ex">boost::</span>algorithm::clamp<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span> <span class="op">-</span> <span class="fl">2.0</span><span class="bu">f</span> <span class="op">*</span> uv<span class="op">[</span><span class="dv">0</span><span class="op">],</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                                                           <span class="op">-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> phi <span class="op">=</span> PI_MUL_2 <span class="op">*</span> uv<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> cosTheta <span class="op">=</span> <span class="bu">std::</span>cos<span class="op">(</span>theta<span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    pdf <span class="op">=</span> PI_INV <span class="op">*</span> cosTheta<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    Vec3f cart <span class="op">=</span> sphericalToCartesian<span class="op">(</span>theta<span class="op">,</span> phi<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cart<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Transformation de système coordonnée</strong></p>
<p>Après d’obtenir une direction de hemisphère, il faut de faire une transformation de système de coordonnées pour qu’on puisse calculer l’intersection de ce rayon avec tous les objet dans la scène.</p>
<p>Voici l’implémentation des fonction de cette transformation.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// transform direction from world to local</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Vec3f worldToLocal<span class="op">(</span><span class="at">const</span> Vec3f <span class="op">&amp;</span>v<span class="op">,</span> <span class="at">const</span> Vec3f <span class="op">&amp;</span>lx<span class="op">,</span> <span class="at">const</span> Vec3f <span class="op">&amp;</span>ly<span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">const</span> Vec3f <span class="op">&amp;</span>lz<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>dot<span class="op">(</span>v<span class="op">,</span> lx<span class="op">),</span> dot<span class="op">(</span>v<span class="op">,</span> ly<span class="op">),</span> dot<span class="op">(</span>v<span class="op">,</span> lz<span class="op">)};</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// transform direction from local to world</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Vec3f localToWorld<span class="op">(</span>Vec3f v<span class="op">,</span> Vec3f lx<span class="op">,</span> Vec3f ly<span class="op">,</span> Vec3f lz<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    Vec3f ret<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> v<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">*</span> lx<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> v<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">*</span> ly<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> v<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">*</span> lz<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Les vecteur <span class="math inline">\(l_x\)</span>, <span class="math inline">\(l_y\)</span> et <span class="math inline">\(l_z\)</span> dans ce code sont les vecteurs orthogonals qui construire le système de coordonnées. Par examples, pour le système de coordonnées local, les trois vecteurs sont <span class="math inline">\(l_x = (1,0,0)\)</span> , <span class="math inline">\(l_y = (0,1,0)\)</span> et <span class="math inline">\(l_z = (0,0,1)\)</span>.</p>
<p>Pour chaque surface dans la scène, vecteur <span class="math inline">\(l_y\)</span> est la normale de surface et les autres vecteurs sont calculées par utiliser le cross produit.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> orthonormalBasis<span class="op">(</span>Vec3f <span class="op">&amp;</span>n<span class="op">,</span> Vec3f <span class="op">&amp;</span>t<span class="op">,</span> Vec3f <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>n<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">&lt;</span> <span class="fl">0.9</span><span class="bu">f</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> normalize<span class="op">(</span>cross<span class="op">(</span>n<span class="op">,</span> Vec3f<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">)));</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> normalize<span class="op">(</span>cross<span class="op">(</span>n<span class="op">,</span> Vec3f<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">)));</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> normalize<span class="op">(</span>cross<span class="op">(</span>t<span class="op">,</span> n<span class="op">));</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="le-problème-des-normales-de-surfaces" class="level2">
<h2 class="anchored" data-anchor-id="le-problème-des-normales-de-surfaces">2. Le problème des normales de surfaces</h2>
<p>Après de lancer la simulation avec 10 millions photons, je trouve qu’il y a aucun photon contacté avec les capteurs en hauteurs 1000 et 1400.</p>
<p style="text-align: center">
<img src="images/photon_result.png" width="800" style="display:block; margin: auto"> <br> Figure 3: Le résultat de simulation courant
</p>
<p>Pour trouver le problème de cette erreur, j’ai déjà fait quelques tests. D’abord, je lance seulement 1 photon par lumière (8 en total) et log tous les directions, l’énergie lumineuse, etc. Et je trouve que le photon tracing est terminé très tôt, après 2 ou 3 fois de réflexion, l’énergie lumineuse va devenir (0,0,0) car le BRDF est 0.</p>
<p>Voici l’implémentation de BRDF de Lambert.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    Vec3f evaluate<span class="op">(</span>Vec3f <span class="op">&amp;</span>wo<span class="op">,</span> Vec3f <span class="op">&amp;</span>wi<span class="op">,</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                   TransportDirection <span class="op">&amp;</span>transport_dir<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// when wo, wi is under the surface, return 0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> cosThetaO <span class="op">=</span> cosTheta<span class="op">(</span>wo<span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> cosThetaI <span class="op">=</span> cosTheta<span class="op">(</span>wi<span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cosThetaO <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> cosThetaI <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rho <span class="op">/</span> PI<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Le BRDF de matériel Lambert est devenu 0 si la couleur de matériel est noir, autrement dit si l’albédo de matériel est (0,0,0). Quand j’ai cherché des objets noirs dans le fiche .rad, il y a seulement des plateaux situé aux deux bouts de lamp et le pots qui sont noirs. Pourtant, après j’ai supprimé ces objets, le résultat n’est encore pas changé.</p>
<p style="text-align: center">
<img src="images/noir_objet.png" width="800" style="display:block; margin: auto"> <br> Figure 4: Les objets noirs dans la scène
</p>
<p>Dans cette implémentation, il existe un autre cas où le BRDF deviens 0, c’est le cosine de l’angle <span class="math inline">\(\theta_i\)</span> et <span class="math inline">\(\theta_o\)</span> sont inférieur 0, autrement dit, la direction situe au dessous de la surface XOY. Il n’existe pas ce cas car tous de nos directions unité sont situé dans le hemisphere supérieur.</p>
<p style="text-align: center">
<img src="images/demisphere.png" width="400" style="display:block; margin: auto"> <br> Figure 5: les directions du hemisphere supérieur
</p>
<p>Après de debugger plus loin, je trouve la cause de cette phenomen. C’est quand on fait la transformation du système de coordonnées de monde au celui de local pour faire des calculs de BRDF, puis faire la transformation inverse pour calculer des intersections, la direction originale de rayon est modifié. En effet, j’ai modifié le code pour examiner la fonction <em>localToWorld</em> et <em>worldToLocal</em> d’un vecteur après d’échantillonnage sur hemisphere supérieur, j’obtiens ces résultats:</p>
<p style="text-align: center">
<img src="images/res_test_vector.png" width="800" style="display:block; margin: auto"> <br> Figure 6: les resultat du test de transformation de système de coordonnées
</p>
<p>On peut voir que il y a 7 par 8 vectors modifé après d’appliquer la transformation de système de coordonnées.</p>
<p><em>Le code modifié</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    Vec3f sampleDirection<span class="op">(</span><span class="at">const</span> SurfaceInfo <span class="op">&amp;</span>surfInfo<span class="op">,</span> Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        Vec3f dir <span class="op">=</span> sampleCosineHemisphere<span class="op">(</span>sampler<span class="op">.</span>getNext2D<span class="op">(),</span> pdf<span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        Vec3f wo <span class="op">=</span> localToWorld<span class="op">(</span>dir<span class="op">,</span> surfInfo<span class="op">.</span>dpdu<span class="op">,</span> surfInfo<span class="op">.</span>shadingNormal<span class="op">,</span> surfInfo<span class="op">.</span>dpdv<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        Vec3f wi <span class="op">=</span> worldToLocal<span class="op">(</span>wo<span class="op">,</span> surfInfo<span class="op">.</span>dpdu<span class="op">,</span> surfInfo<span class="op">.</span>shadingNormal<span class="op">,</span> surfInfo<span class="op">.</span>dpdv<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> dir <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> wi <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span> length<span class="op">(</span>dir <span class="op">-</span> wi<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">0.0001</span> <span class="op">){</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"err"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// transform direction from local to world</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> wo<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Comme on a déjà vu dans la partie avante, tous les calculs de transformation de système de coordonnées sont lié beaucoup à la normale de surface. Alors, si la normale n’est pas correct, notre fontion de transformtion n’est aussi pas correct.</p>
<p>Dans notre simulation, on calcule tous les normals de triangles automatiquement par OpenAlea.PlantGL après de définir tous les vertices et les ordres de vertices des triangles. Le problème que je trouve est dans cette phase. En fait, c’est quand on defini la forme de cylinder d’une source de lumière.</p>
<p>Le code pour faire des vertices</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> type <span class="op">==</span> <span class="st">"cylinder"</span><span class="op">:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> re<span class="op">.</span>split<span class="op">(</span>r<span class="st">"</span><span class="er">\s</span><span class="st">+|;+"</span><span class="op">,</span> lines<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    l2 <span class="op">=</span> re<span class="op">.</span>split<span class="op">(</span>r<span class="st">"</span><span class="er">\s</span><span class="st">+|;+"</span><span class="op">,</span> lines<span class="op">[</span>i <span class="op">+</span> <span class="dv">2</span><span class="op">])</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    l3 <span class="op">=</span> re<span class="op">.</span>split<span class="op">(</span>r<span class="st">"</span><span class="er">\s</span><span class="st">+|;+"</span><span class="op">,</span> lines<span class="op">[</span>i <span class="op">+</span> <span class="dv">3</span><span class="op">])</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>l3<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">/</span> scale_factor</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    x<span class="op">,</span> y<span class="op">,</span> z <span class="op">=</span> <span class="op">(</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span><span class="op">(</span>l<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">/</span> scale_factor<span class="op">,</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span><span class="op">(</span>l<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">/</span> scale_factor<span class="op">,</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span><span class="op">(</span>l<span class="op">[</span><span class="dv">2</span><span class="op">])</span> <span class="op">/</span> scale_factor<span class="op">,</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    x2<span class="op">,</span> y2<span class="op">,</span> z2 <span class="op">=</span> <span class="op">(</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span><span class="op">(</span>l2<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">/</span> scale_factor<span class="op">,</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span><span class="op">(</span>l2<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">/</span> scale_factor<span class="op">,</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span><span class="op">(</span>l2<span class="op">[</span><span class="dv">2</span><span class="op">])</span> <span class="op">/</span> scale_factor<span class="op">,</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    vert<span class="op">.</span>append<span class="op">((</span>x <span class="op">+</span> r<span class="op">,</span> y <span class="op">+</span> r<span class="op">,</span> z <span class="op">+</span> r<span class="op">))</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    vert<span class="op">.</span>append<span class="op">((</span>x <span class="op">-</span> r<span class="op">,</span> y <span class="op">-</span> r<span class="op">,</span> z <span class="op">-</span> r<span class="op">))</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    vert<span class="op">.</span>append<span class="op">((</span>x2 <span class="op">+</span> r<span class="op">,</span> y2 <span class="op">+</span> r<span class="op">,</span> z2 <span class="op">+</span> r<span class="op">))</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    vert<span class="op">.</span>append<span class="op">((</span>x2 <span class="op">-</span> r<span class="op">,</span> y2 <span class="op">-</span> r<span class="op">,</span> z2 <span class="op">-</span> r<span class="op">))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>le code pour faire des triangles</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    ts <span class="op">=</span> TriangleSet<span class="op">(</span>vert<span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    indList <span class="op">=</span> <span class="op">[]</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> nbCoords<span class="op">:</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> invert_normals<span class="op">:</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            ind <span class="op">=</span> Index3<span class="op">(</span>i<span class="op">,</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            ind2 <span class="op">=</span> Index3<span class="op">(</span>i<span class="op">,</span> i <span class="op">+</span> <span class="dv">3</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            ind <span class="op">=</span> Index3<span class="op">(</span>i<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            ind2 <span class="op">=</span> Index3<span class="op">(</span>i<span class="op">,</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        indList<span class="op">.</span>append<span class="op">(</span>ind<span class="op">)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        indList<span class="op">.</span>append<span class="op">(</span>ind2<span class="op">)</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">4</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    ts<span class="op">.</span>indexList <span class="op">=</span> Index3Array<span class="op">(</span>indList<span class="op">)</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    ts<span class="op">.</span>computeNormalList<span class="op">()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>En fait, après de lire dans le fiche .rad, on obtiens deux points correspondant la longueur de lamp. Pour créer un carré, on ajoute 4 point autour les deux points comme dans l’image suivante.</p>
<p style="text-align: center">
<img src="images/triangulate_1.png" width="500" style="display:block; margin: auto"> <br> Figure 7: Ajouter des vertices
</p>
<p>Ensuite, on définir un ordre de chaque group de 3 vertices pour créer des triangles.</p>
<p style="text-align: center">
<img src="images/triangulate_2.png" width="500" style="display:block; margin: auto"> <br> Figure 8: Créer des triangles
</p>
<p>Ci-dessus, c’est le résultat de notre code courant et il est facile d’aperçevoir que ce n’est pas bon.</p>
<p>Pour tester si la transformation de système de coordonnées est bon avec des bonnes triangles, j’ai modifie les ordres des triangles un peu.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>vert<span class="op">.</span>append<span class="op">((</span>x <span class="op">+</span> r<span class="op">,</span> y <span class="op">+</span> r<span class="op">,</span> z <span class="op">+</span> r<span class="op">))</span>       </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>vert<span class="op">.</span>append<span class="op">((</span>x2 <span class="op">+</span> r<span class="op">,</span> y2 <span class="op">+</span> r<span class="op">,</span> z2 <span class="op">+</span> r<span class="op">))</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>vert<span class="op">.</span>append<span class="op">((</span>x2 <span class="op">-</span> r<span class="op">,</span> y2 <span class="op">-</span> r<span class="op">,</span> z2 <span class="op">-</span> r<span class="op">))</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>vert<span class="op">.</span>append<span class="op">((</span>x <span class="op">-</span> r<span class="op">,</span> y <span class="op">-</span> r<span class="op">,</span> z <span class="op">-</span> r<span class="op">))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p style="text-align: center">
<img src="images/triangulate_3.png" width="500" style="display:block; margin: auto"> <br> Figure 9: Modifier les ordre des vertices
</p>
<p>Voici les résultats.</p>
<p style="text-align: center">
<img src="images/res_test_vector_2.png" width="800" style="display:block; margin: auto"> <br> Figure 10: Resultat avec des bonnes triangles
</p>
<p>On peut voir que les résultats sont très bien. Pourtant, dans notre simulation, à côté de la lumière, il y a beaucoup d’objets qui a la forme d’un carré et cela influence aussi à la simulation.</p>
<p>Dans la semaine prochaine, je vais essayer à corriger ces erreurs pour voir si le résultat de simulation est amélioré.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>