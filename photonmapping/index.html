<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="i.-état-de-lart" class="level1">
<h1>I. État de l’art</h1>
<section id="modèles-déclairement" class="level2">
<h2 class="anchored" data-anchor-id="modèles-déclairement">1.1. Modèles d’éclairement</h2>
<p>La couleur est une phénomène qui dépend, d’une part, de la physique de la lumière et son interaction avec les matériaux, d’autre part, de l’interprétation des phénomènes résultats par le système visuel humain.</p>
<section id="la-système-visuelle-dhumain" class="level3">
<h3 class="anchored" data-anchor-id="la-système-visuelle-dhumain">1.1.1. La système visuelle d’humain</h3>
<section id="loeil-humain" class="level4">
<h4 class="anchored" data-anchor-id="loeil-humain">1.1.1.1. L’oeil humain</h4>
<p style="text-align: center">
<img src="images/eye.png" width="400" style="display:block; margin: auto"> <br> Figure 1: Coupe de l’oeil humain
</p>
<p>La figure 1 présente une coupe de l’oeil humain. L’iris joue le rôle du diaphragme de l’appareil photographique et la pupille celui de la lentile. L’image se forme sur la rétine qui est la surface de l’oeil sensible à la lumière. Sur la rétine, il existe deux types de cellules photo céceptrices qui transforment la lumière en impulsions nerveuses: les cônes et les bâtonnets. Les bâtonnets sont plus sensibles à la lumière que les cônes et permettent la vision nocturne. Les cônes servent à la vision des couleurs et à la vision diurne.</p>
<p>Il existe trois type de cônes, qui diffèrent suivant leur sensibilité aux longueurs d’ondes: certains sont sensibles aux courtes longueurs d’ondes (cônes bleus), les autres ont une sensibilité maximale à 535 nm (cônes verts) ou à 575 nm (cônes rouges).</p>
</section>
<section id="le-mécanisme-visuel" class="level4">
<h4 class="anchored" data-anchor-id="le-mécanisme-visuel">1.1.1.2. Le mécanisme visuel</h4>
<p>Le mécanisme visuel correspond au schéma suivant: un stimulus externe provoque l’activation d’un cône ou d’un bâtonnet qui produit une transition photochimique, laquelle induit de l’influx nerveux. Les impulsions nerveuses fournis par les cônes sont recombinées en trois nouveaux canaux: le premier indique la luminance, le deuxième la différence entre le rouge et le vert et le troisième la différence entre le jaune et le bleu.</p>
</section>
</section>
<section id="modèles-locaux" class="level3">
<h3 class="anchored" data-anchor-id="modèles-locaux">1.1.2. Modèles locaux</h3>
<p>Depuis des années, la synthèse d’images s’applique à définir des modèles de réflexion simulant le plus fidèlement possible la réponse d’un matériau quelconque à une incidence lumineuse. Cependant, l’interaction entre la lumière et la matière est un problème très difficile à modéliser parfaitement en raison de sa complexité. Maintenant, cette interaction est appliquée à de nombreux objectifs tels que la simulation physique ou le rendu temps réel. Et un des techniques qu’on utilise souvent pour ce calcul est la fonction de BRDF.</p>
<section id="définition-de-la-brdf" class="level4">
<h4 class="anchored" data-anchor-id="définition-de-la-brdf">1.1.2.1. Définition de la BRDF</h4>
<p style="text-align: center">
<img src="images/BRDF.png" width="400" style="display:block; margin: auto"> <br> Figure 2: Le modèle de BRDF
</p>
<p>La luminance est une mesure radiométrique définissant la qualité d’énergie, dans notre cas l’énergie lumineuse, qui est émise ou reçue par une surface élémentaire dans un angle solide élémentaire autour d’une direction donnée. La luminance s’exprime en Watts par unité d’aire et par unité d’angle solide <span class="math inline">\(W.m^{-2}.sr^{-1}\)</span>. L’énergie qui arrive sur une portion de surface dans une portion d’angle solide <em><span class="math inline">\(d\omega_i\)</span></em>:</p>
<p><span class="math display">\[dL_i(x, \omega_i) = L_i(x, \omega_i) cos(\vec{N_x}, \omega_i) d\omega_i\]</span></p>
<p>avec:</p>
<ul>
<li><span class="math inline">\(L_i(x, \omega_i)\)</span> est l’énergie reçcue en x</li>
<li><span class="math inline">\(\omega_i\)</span> est la direction d’éclairement</li>
<li><span class="math inline">\(\vec{N_x}\)</span> est la normale de surface</li>
<li><span class="math inline">\(d\omega_i\)</span> est l’angle solide</li>
</ul>
<p>La fonction de distribution de la réflectance bidirectionnelle (BRDF) décrit la réflextion d’une onde lumineuse sur une surface. En effet, pour une direction d’éclairement <em><span class="math inline">\(\omega_i\)</span></em> et une direction de réflexion <em><span class="math inline">\(\omega_r\)</span></em>, la BRDF est le rapport de la luminance réflechie en un point <em>x</em> d’une surface infinitésimale d’aire <em>dA</em> à l’éclairement incident à celle-ci.</p>
<p><span class="math display">\[f_r(x, \omega_i, \omega_r, \lambda) = f_r(x, \theta_i, \phi_i, \theta_r, \phi_r, \lambda) = \frac{dL_r(x,\theta_r, \phi_r, \lambda)}{dL_i(x, \theta_i, \phi_i, \lambda)} = \frac{dL_r(x,\theta_r, \phi_r, \lambda)}{L_i(x, \theta_i, \phi_i, \lambda) cos\theta_i d\omega_i}\]</span></p>
<p>avec:</p>
<ul>
<li><span class="math inline">\(\theta_i\)</span> est l’angle entre <span class="math inline">\(\omega_i\)</span> et <span class="math inline">\(\vec{N_x}\)</span></li>
<li><span class="math inline">\(\theta_r\)</span> est l’angle entre <span class="math inline">\(\omega_r\)</span> et <span class="math inline">\(\vec{N_x}\)</span></li>
</ul>
</section>
<section id="le-modèle-de-lambert" class="level4">
<h4 class="anchored" data-anchor-id="le-modèle-de-lambert">1.1.2.2. Le modèle de Lambert</h4>
<p style="text-align: center">
<img src="images/Lambert6.gif" width="400" style="display:block; margin: auto;"> <br> Figure 3: Lambertian reflectance
</p>
<p>Le modèle de Lambert, qui suppose une surface parfaitement diffuse. C’est-à-dire que la lumière est réflechie de façon équiprobable par le matériau dans toutes les directions. La BRDF est donc constante et indépendante des directions d’éclairement, de réflexion, et de la longueur d’onde:</p>
<p><span class="math display">\[f_r(\omega_i,\omega_r) = \frac{1}{\pi}\]</span></p>
<p>En réalité, les surfaces ne réflechissent qu’une partie de la lumière (l’autre étant absorbée). C’est pourquoi on utilise parfois le modèle suivantpour caractériser une surface dite Lambertienne:</p>
<p><span class="math display">\[f_r(\omega_i,\omega_r) = \frac{C}{\pi}\]</span></p>
<p>avec:<br>
<span class="math inline">\(C\)</span> est le longueur d’onde de la lumière</p>
</section>
<section id="le-modèle-de-phong" class="level4">
<h4 class="anchored" data-anchor-id="le-modèle-de-phong">1.1.2.3. Le modèle de Phong</h4>
<p style="text-align: center">
<img src="images/Blinn_Vectors.svg.png" width="400" style="display:block; margin: auto; background: white"> <br> Figure 4: Les vecteurs utilisé dans le modèle de Phong
</p>
<p>Le modèle de Phong est le modèle le plus utilisé en synthèse d’image. Ce modèle est basé sur la combinaison linéaire d’un comportement diffus et d’un comportement directionnelle. La BRDF est représenté par cette formule:</p>
<p><span class="math display">\[f(\vec{L}, \vec{V}) = k_d + k_s \frac{ F_s(\vec{L}, \vec{V})}{(\vec{N}.\vec{L})}\]</span></p>
<p>avec: * <span class="math inline">\(\vec{L}\)</span> est la direction à la lumière * <span class="math inline">\(\vec{V}\)</span> est la direction de reflexion * <span class="math inline">\(\vec{N}\)</span> est la normale de surface * <span class="math inline">\(k_d\)</span> est la couleur diffuse de l’objet * <span class="math inline">\(k_s\)</span> est la couleur spéculaire de l’objet</p>
<p>Le terme <span class="math inline">\(F_s(\vec{L}, \vec{V})\)</span> est appelé lobe spéculaire. Il peut être exprimée de plusieurs manières. Originalement, Phong avait proposé l’expression suivant:</p>
<p><span class="math display">\[F_s^P(\vec{L}, \vec{V}) =  \left\{ \begin{array}{rcl}
  (\vec{R}.\vec{V})^n &amp; si \vec{R}.\vec{V} &gt; 0  \\ 0 &amp; sinon
  \end{array} \right.  \]</span></p>
<p>avec: * <span class="math inline">\(\vec{V}\)</span> est la direction de réflexion en réelle * <span class="math inline">\(\vec{R}\)</span> est la direction de réflexion définie par la première loi de Descarte; et exprimée par: <span class="math inline">\(\vec{R} = 2(\vec{L}.\vec{N})\vec{N} - \vec{L}\)</span> * <span class="math inline">\(n\)</span> est la rugosité de la surface. Plus n est grand, plus la surface apparaît lisse.</p>
<p>Dans la première loi de Descartes, quand un rayon de lumière <span class="math inline">\(\vec{L}\)</span> contacte un surface, il va génère un rayon de réflexion <span class="math inline">\(\vec{R_1}\)</span> et un rayon de réfraction <span class="math inline">\(\vec{R_2}\)</span>. Les relation entre ces rayons sont répresenté par ces équations:</p>
<p><span class="math display">\[i_1 = i_1'\]</span> <span class="math display">\[n_1 Sin(i_1) = n_2 Sin (i_2)\]</span></p>
<p>avec: * <span class="math inline">\(i_1\)</span> est l’angle entre le rayon entré et la normale * <span class="math inline">\(i_1'\)</span> est l’angle entre le rayon de réflexion et la normale * <span class="math inline">\(i_2\)</span> est l’angle entre le rayon de réfraction et la normale * <span class="math inline">\(n_1\)</span> est l’indice de réfraction de milieu 1 * <span class="math inline">\(n_2\)</span> est l’indice de réfraction de milieu 2</p>
<p style="text-align: center">
<img src="images/decartes.png" width="400" style="display:block; margin: auto; background: white"> <br> Figure 5: La première loi de Dsecartes
</p>
<p>L’indice de réfraction est la ratio entre la vitesse de la lumière dans la vide et dans un milieu considèré. Il est exprimée par cette formule:</p>
<p><span class="math display">\[n = \frac{c}{v}\]</span></p>
<p>avec: * <span class="math inline">\(c\)</span> est la vitesse de la lumière dans le vide, environ <span class="math inline">\(3.10⁸ m.s^{-1}\)</span> * <span class="math inline">\(v\)</span> est la vitesse de la lumière dans le milieu considèré</p>
<p><strong>Physiquement plausible</strong></p>
<p>Malgré que le modèle original de Phong est utilisé dans beaucoup de système de rendu, ce modèle n’adapte pas les facteurs physiques suivant: * La conservation d’énergie: BRDF $ $ 1 * La réciprocité: <span class="math inline">\(f(\vec{L}, \vec{V}) = f(\vec{V}, \vec{L})\)</span></p>
<p>Afin de rendre le modèle de Phong physiquement plausible, en 1993, Lewis nous a proposé ensemble de constraintes sur les paramètres permettant de respecter la conservation d’énergie.</p>
<p><span class="math display">\[k_d + k_s \le 1\]</span></p>
<p>Le problème de la réciprocité peut être résoudre par utiliser le terme spéculaire proposé par Blinn.</p>
<p><strong>Modèle Blinn-Phong</strong></p>
<p>À côté de l’expression du terme spéculaire proposé par Phong, il existe aussi une autre expression de ce terme. Ci-dessous, c’est la formule proposé par Blinn:</p>
<p><span class="math display">\[ F_s^B(\vec{L}, \vec{V}) = (\vec{N}.\vec{H})^n \]</span></p>
<p>avec: * <span class="math inline">\(\vec{H}\)</span> est le vector à mi-distance entre <span class="math inline">\(\vec{V}\)</span> et <span class="math inline">\(\vec{L}\)</span></p>
</section>
<section id="léquation-de-fresnel" class="level4">
<h4 class="anchored" data-anchor-id="léquation-de-fresnel">1.1.2.3. L’équation de Fresnel</h4>
<p>L’équation de Fresnel est une équation utilisé pour calculer l’énergie de réflexion et l’énergie de réfraction au cas où la lumière contacte un matériel transparent tels que la verre ou l’eau. La lumière est composée de deux ondes perpendiculaires que nous appelons la lumière polarisée parallèle et perpendiculaire. On a deux équation de Fresnel:</p>
<p><span class="math display">\[ F_{R\parallel} = \left(\frac{n_2 Cos \theta_1 - n_1 Cos \theta_2 }{ n_2 Cos \theta_1 + n_1 Cos \theta_2 } \right)²  \]</span></p>
<p><span class="math display">\[ F_{R\perp} = \left(\frac{n_2 Cos \theta_2 - n_1 Cos \theta_1 }{ n_2 Cos \theta_2 + n_1 Cos \theta_1 } \right)²  \]</span></p>
<p>avec: * <span class="math inline">\(\theta_1\)</span> est l’angle entre le rayon d’éclairement et la normale * <span class="math inline">\(\theta_2\)</span> est l’angle entre le rayon de réflexion et la normale * <span class="math inline">\(n_1\)</span> est l’indice de réfraction de milieu 1 * <span class="math inline">\(n_2\)</span> est l’indice de réfraction de milieu 2</p>
<p>Par calculer le moyenne de ces deux valeurs, on obtiens le ratio entre l’énergie de réflexion et l’énergie d’émise:</p>
<p><span class="math display">\[ F_R = \frac{1}{2} (F_{ R\parallel} + F_{R\perp} ) \]</span></p>
<p>Grâce à la conservation d’énergie, on peut calculer le ratio entre l’énergie de réfraction et l’énergie d’émise:</p>
<p><span class="math display">\[F_T = 1 - F_R\]</span></p>
</section>
<section id="les-autres-fonctions-de-bxdf" class="level4">
<h4 class="anchored" data-anchor-id="les-autres-fonctions-de-bxdf">1.1.2.4. Les autres fonctions de BxDF</h4>
<p>À côté de la fonction BRDF, il existe aussi des autres fonctions qui s’adaptent aux différents type de matériaux, tels ques:</p>
<ul>
<li><p><em>Bidirectional Transmittance Distribution Function (BTDF):</em> Le cas où la lumière est réfracté complètement</p></li>
<li><p><em>Bidirectional Scattering Distribution Function (BSDF):</em> Le cas où une partie de la lumière est diffusée tandis que l’autre est réfracté.</p></li>
<li><p><em>Bidirectional Sous-Surfaque Reflectance Distribution Function (BSSRDF):</em> Le cas où la lumière est diffusée sous la surface d’un matériel (la peau).</p></li>
</ul>
</section>
</section>
<section id="modèles-globaux" class="level3">
<h3 class="anchored" data-anchor-id="modèles-globaux">1.1.3. Modèles globaux</h3>
<p>Dans la section avant, on a vu le modèle qui permet de calculer l’éclairement d’une surface de manière locale, c’est-à-dire sans prendre en compte la participation de l’ensemble des objets constituant une scène dans l’apparence d’un seul objet. En effet, elle ne prennent en compte que la réflexion directe des sources de lumières, alors que la lumière peut subir plusieurs réflexions avant d’atteindre un objet.</p>
<p><em>L’équation de rendu</em></p>
<p>L’expression de la lumière <span class="math inline">\(L(x \rightarrow \omega)\)</span> émise en une point <em>x</em> d’une surface et dans une direction <span class="math inline">\(\omega\)</span> est répresenté par:</p>
<p><span class="math display">\[ L (x \rightarrow \omega) = L_e(x \rightarrow \omega) + L_r(x \rightarrow \omega)  \]</span></p>
<p>avec: * <span class="math inline">\(L_e(x \rightarrow \omega)\)</span> est la luminance propre émise (comme pour une source de lumière) * <span class="math inline">\(L_r(x \rightarrow \omega)\)</span> est la réflexion de toute la lumière qui arrive sur cette surface</p>
<p>On sait que la réflexion est contrôlée par la fonction BRDF:</p>
<p><span class="math display">\[ f_r (x, \omega \rightarrow \omega') = \frac{L_r(x \rightarrow \omega)}{L(x \leftarrow \omega')|cos(\vec{N_x}, \omega')|d\omega'}  \]</span></p>
<p>avec: * <span class="math inline">\(\omega\)</span> est la direction de réflexion * <span class="math inline">\(\omega'\)</span> est la direction d’éclarement * <span class="math inline">\(\vec{N_x}\)</span> est la normale de surface * <span class="math inline">\(L_r(x \rightarrow \omega)\)</span> est la réflexion de toute la lumière qui arrive sur cette surface * <span class="math inline">\(L(x \leftarrow \omega')\)</span> est la luminance reçue dans la direction <span class="math inline">\(\omega\)</span>’</p>
<p>On a l’équation de rendu au final:</p>
<p><span class="math display">\[ L (x \rightarrow \omega) = L_e(x \rightarrow \omega) + \int_{\Omega} f_r (x, \omega \rightarrow \omega')L(x \leftarrow \omega')|cos(\vec{N_x}, \omega')|d\omega'   \]</span></p>
</section>
</section>
<section id="photon-mapping" class="level2">
<h2 class="anchored" data-anchor-id="photon-mapping">1.2. Photon Mapping</h2>
<p>Le Photon Mapping est la méthode utilisé beaucoup dans les simulations d’interception de la lumière. Il y a deux phases principales dans cette technique, ce sont: * <em>Photon Tracing:</em> Construire la carte de photon * <em>Photon Collecting:</em> Estimer l’énergie lumineuse de chaque pixel d’image</p>
<section id="photon-tracing" class="level3">
<h3 class="anchored" data-anchor-id="photon-tracing">1.2.1. Photon Tracing</h3>
<p style="text-align: center">
<img src="images/photon_tracing.png" width="400" style="display:block; margin: auto;"> <br> Figure 6: La phase de Photon Tracing
</p>
<p>Afin de cosntruire la carte de photon, on va lancer plusieurs rayons à partir des sources de lumières et stocker des impacts de chaque rélfexions, ainsi que leurs énergie <span class="math inline">\(\phi\)</span> en Watts (W). Ces impacts sont les <em>photons</em> dans notre carte de photon. Si l’émission de N échantillons est guidée par la densité de probabilité <span class="math inline">\(p(x, \omega)\)</span>, l’énergie de chaque photon est calculer par cette équation:</p>
<p><span class="math display">\[ \phi = \frac{L(x \rightarrow \omega) |cos(\vec{N_x}, \omega)|}{Np(x,\omega)} \]</span></p>
<p>avec: * <span class="math inline">\(N\)</span> est le nombre d’échantions * <span class="math inline">\(L(x \rightarrow \omega)\)</span> est l’énergie reçue en <em>x</em> * <span class="math inline">\(\vec{N_x}\)</span> est la normale du surface * <span class="math inline">\(\omega\)</span> est la direction d’éclairement * <span class="math inline">\(p(x, \omega)\)</span> est la densité de probabilité (PDF)</p>
<p>Ci-dessous, ce sont des valeurs de PDF qui corresponds quelques cas d’échantillonage:</p>
<ul>
<li>Échantillonnage d’une direction uniforme sur une sphère-unité centrée : <span class="math inline">\(p(\omega) = 1/(4\pi)\)</span></li>
<li>Échantillonnage d’une direction uniforme sur une demi sphère-unité centrée : <span class="math inline">\(p(\omega) = 1/(2\pi)\)</span></li>
<li>Échantillonnage d’une direction selon le cosinus à la normale : <span class="math inline">\(p(\omega) = |cos(\vec{N}, \omega)|/\pi\)</span></li>
<li>Échantillonnage d’une direction uniforme d’un triangle d’aire A : <span class="math inline">\(p(\omega) = 1/A\)</span></li>
</ul>
</section>
<section id="photon-collecting" class="level3">
<h3 class="anchored" data-anchor-id="photon-collecting">1.2.2. Photon Collecting</h3>
<p style="text-align: center">
<img src="images/photon_colect.gif" width="400" style="display:block; margin: auto;"> <br> Figure 7: La phase de Photon Collecting
</p>
<p>Après d’obtenir la carte de photon, on va l’utiliser pour faire le rendu d’image. Pour chaque pixel d’image, on va lancer un rayon à partir de caméra, puis calculer le point d’intersection <em>x</em> entre ce rayon et tous les objets dans la scène. Si S est la surface qui contiens <em>x</em> et <span class="math inline">\(p_i\)</span> est la position du <span class="math inline">\(i^{me}\)</span> photon d’énergie <span class="math inline">\(\phi_i\)</span>, l’énergie reçue en Watts est:</p>
<p><span class="math display">\[E = \sum_{p_i \in S }\phi_i\]</span></p>
<p>ou, en Watts par mètre carré, avec A est l’aire de la surface S:</p>
<p><span class="math display">\[ I = \frac{1}{A}\sum_{p_i \in S }\phi_i\]</span></p>
</section>
</section>
</section>
<section id="ii.-implémentation" class="level1">
<h1>II. Implémentation</h1>
<p>Tous les codes d’implémentation est trouvé sur le Github de Aurélien Besnier dans la lien suivant : https://github.com/AurelienBesnier/photon_mapping</p>
<section id="matériel" class="level2">
<h2 class="anchored" data-anchor-id="matériel">2.1. Matériel</h2>
<p>Avant d’implémenter des différents type de matériels, il faut d’implémenter la classe BxDF qui contiens des méthodes de calculer la réflexion de la lumière. Ensuite, toutes les classes de matériels vont héritées cette classe. Maintenant, dans notre projet, on a déjà défini 3 types de BxDF, ce sont: * <strong>Diffuse :</strong> La réflexion diffuse est parait sur les surface non polies où la lumière est réfléchie dans plusieurs directions. Il est impossible d’avoir un image claire en observant un objet sur ce type de surface * <strong>Specular :</strong> La réflexion spéculaire est une réflexion régulière de la lumière. Contrairement à la réflexion diffuse, elle ne peut exister que si les rayons lumineux rencontrent une surface parfaitement plane ou polie tels ques les miroirs ou une surface d’eau parfaitement calme * <strong>Captor :</strong> Ce type de BxDF n’influence pas la calculation de lumière dans la simulation. Il est utilisé seulement pour capturer l’énergie lumineuse dans une région déterminé.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> BxDFType <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    DIFFUSE<span class="op">,</span> <span class="co">///&lt; Diffuse surface</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    SPECULAR<span class="op">,</span> <span class="co">///&lt; Specular surface</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    CAPTOR <span class="co">///&lt; Captor surface</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Ci-dessous, c’est l’implémentation raccourcie de la classe BxDF. Il contient un constructor, une fonction de calculer le BxDF et une fonction d’échantillonner la direction de réflexion. La version complète de ce code est trouvé ici: https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/material.hpp#L49</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BxDF <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    BxDFType type<span class="op">;</span> <span class="co">///&lt; The type of BxDF.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> BxDF<span class="op">(</span><span class="at">const</span> BxDFType <span class="op">&amp;</span>type<span class="op">)</span> <span class="op">:</span> type<span class="op">(</span>type<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// evaluate BxDF</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> Vec3f evaluate<span class="op">(</span>Vec3f <span class="op">&amp;</span>wo<span class="op">,</span> Vec3f <span class="op">&amp;</span>wi<span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                           TransportDirection <span class="op">&amp;</span>transport_dir<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sample direction by BxDF.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// its pdf is proportional to the shape of BxDF</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> Vec3f sampleDirection<span class="op">(</span>Vec3f <span class="op">&amp;</span>wo<span class="op">,</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                                  TransportDirection <span class="op">&amp;</span>transport_dir<span class="op">,</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                                  Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> Vec3f <span class="op">&amp;</span>wi<span class="op">,</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                                  <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Dans notre projet, on utilise 4 types de matériels pour construire l’environnement de cette simulation: * Lambert * Transparent * Feuil * Captor</p>
<section id="matériel-de-lambert" class="level3">
<h3 class="anchored" data-anchor-id="matériel-de-lambert">2.1.1. Matériel de Lambert</h3>
<p>Le matériel de Lambert est un type de matériel très basique dans notre projet. Il est utilisé pour répresetner la plupart des objets dans la scène tels ques les murs ou la table.</p>
<p><span class="math display">\[f_r(\omega_i,\omega_r) = \frac{C}{\pi}\]</span></p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/material.hpp#L123</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Lambert <span class="op">:</span> <span class="kw">public</span> BxDF <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    Vec3f rho<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> Lambert<span class="op">(</span><span class="at">const</span> Vec3f <span class="op">&amp;</span>rho<span class="op">)</span> <span class="op">:</span> BxDF<span class="op">(</span>BxDFType<span class="op">::</span>DIFFUSE<span class="op">),</span> rho<span class="op">(</span>rho<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    Vec3f evaluate<span class="op">(</span>Vec3f <span class="op">&amp;</span>wo<span class="op">,</span> Vec3f <span class="op">&amp;</span>wi<span class="op">,</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                   TransportDirection <span class="op">&amp;</span>transport_dir<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// when wo, wi is under the surface, return 0</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> cosThetaO <span class="op">=</span> cosTheta<span class="op">(</span>wo<span class="op">);</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> cosThetaI <span class="op">=</span> cosTheta<span class="op">(</span>wi<span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cosThetaO <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> cosThetaI <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rho <span class="op">/</span> PI<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    Vec3f sampleDirection<span class="op">(</span>Vec3f <span class="op">&amp;</span>wo<span class="op">,</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                          TransportDirection <span class="op">&amp;</span>transport_dir<span class="op">,</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                          Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> Vec3f <span class="op">&amp;</span>wi<span class="op">,</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// cosine weighted hemisphere sampling</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        wi <span class="op">=</span> sampleCosineHemisphere<span class="op">(</span>sampler<span class="op">.</span>getNext2D<span class="op">(),</span> pdf<span class="op">);</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> evaluate<span class="op">(</span>wo<span class="op">,</span> wi<span class="op">,</span> transport_dir<span class="op">);</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La densité de probabilité (pdf) dans <em>la partie 1.2.1</em> est calculer par ce code:</p>
<p><span class="math display">\[p(\omega) = \frac{|cos(\vec{N}, \omega)|}{\pi}\]</span></p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/sampler.hpp#L103</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> Vec3f sampleCosineHemisphere<span class="op">(</span>Vec2f uv<span class="op">,</span> <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> theta <span class="op">=</span> <span class="fl">0.5</span><span class="bu">f</span> <span class="op">*</span> <span class="bu">std::</span>acos<span class="op">(</span><span class="ex">boost::</span>algorithm::clamp<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span> <span class="op">-</span> <span class="fl">2.0</span><span class="bu">f</span> <span class="op">*</span> uv<span class="op">[</span><span class="dv">0</span><span class="op">],</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                                                           <span class="op">-</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> phi <span class="op">=</span> PI_MUL_2 <span class="op">*</span> uv<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> cosTheta <span class="op">=</span> <span class="bu">std::</span>cos<span class="op">(</span>theta<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    pdf <span class="op">=</span> PI_INV <span class="op">*</span> cosTheta<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    Vec3f cart <span class="op">=</span> sphericalToCartesian<span class="op">(</span>theta<span class="op">,</span> phi<span class="op">);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cart<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="matériel-de-transparence" class="level3">
<h3 class="anchored" data-anchor-id="matériel-de-transparence">2.1.2. Matériel de transparence</h3>
<p>Comme le matériel de Lambert, le matériel de transparence est aussi un matériel très basique. Il est utilisé pour répresenter les matériaux qui permettent la lumière de traverser tels ques les verres, l’eau, etc.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/material.hpp#L404</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Transparent <span class="op">:</span> <span class="kw">public</span> BxDF <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    Vec3f rho<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> ior<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    Transparent<span class="op">(</span><span class="at">const</span> Vec3f <span class="op">&amp;</span>rho<span class="op">,</span> <span class="dt">float</span> ior<span class="op">)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> BxDF<span class="op">(</span>BxDFType<span class="op">::</span>DIFFUSE<span class="op">),</span> rho<span class="op">(</span>rho<span class="op">),</span> ior<span class="op">(</span>ior<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">NOTE</span><span class="co">: delta function</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    Vec3f evaluate<span class="op">(</span>Vec3f <span class="op">&amp;</span>wo<span class="op">,</span> Vec3f <span class="op">&amp;</span>wi<span class="op">,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                   TransportDirection <span class="op">&amp;</span>transport_dir<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> cosThetaO <span class="op">=</span> cosTheta<span class="op">(</span>wo<span class="op">);</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> cosThetaI <span class="op">=</span> cosTheta<span class="op">(</span>wi<span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cosThetaO <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> cosThetaI <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rho <span class="op">/</span> PI<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    Vec3f sampleDirection<span class="op">(</span>Vec3f <span class="op">&amp;</span>wo<span class="op">,</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>                          TransportDirection <span class="op">&amp;</span>transport_dir<span class="op">,</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>                          Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> Vec3f <span class="op">&amp;</span>wi<span class="op">,</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// set appropriate ior, normal</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> iorO<span class="op">,</span> iorI<span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        Vec3f n<span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>wo<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            iorO <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>            iorI <span class="op">=</span> ior<span class="op">;</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            n <span class="op">=</span> Vec3f<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            iorO <span class="op">=</span> ior<span class="op">;</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            iorI <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>            n <span class="op">=</span> Vec3f<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// fresnel reflectance</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> fr <span class="op">=</span> fresnelR<span class="op">(</span>dot<span class="op">(</span>wo<span class="op">,</span> n<span class="op">),</span> iorO<span class="op">,</span> iorI<span class="op">);</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">// reflection</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>sampler<span class="op">.</span>getNext1D<span class="op">()</span> <span class="op">&lt;</span> fr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>            wi <span class="op">=</span> reflect<span class="op">(</span>wo<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>            pdf <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>            <span class="co">//bxdf = rho / PI</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>            <span class="co">//pdf = cosTheta / PI</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>            <span class="co">//===&gt; bxdf / pdf = rho / cosTheta</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> rho <span class="op">/</span> absCosTheta<span class="op">(</span>wi<span class="op">);</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>            <span class="co">// refraction</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>            Vec3f <span class="fu">tr</span><span class="op">;</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>refract<span class="op">(</span>wo<span class="op">,</span> n<span class="op">,</span> iorO<span class="op">,</span> iorI<span class="op">,</span> <span class="fu">tr</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>                wi <span class="op">=</span> <span class="fu">tr</span><span class="op">;</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>                pdf <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>                <span class="dt">float</span> scaling <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>transport_dir <span class="op">==</span> TransportDirection<span class="op">::</span>FROM_CAMERA<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>                    scaling <span class="op">=</span> <span class="op">(</span>iorO <span class="op">*</span> iorO<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>iorI <span class="op">*</span> iorI<span class="op">);</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> scaling <span class="op">*</span> rho <span class="op">/</span> absCosTheta<span class="op">(</span>wi<span class="op">);</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>                <span class="co">// total reflection</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>                wi <span class="op">=</span> reflect<span class="op">(</span>wo<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>                pdf <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> rho <span class="op">/</span> absCosTheta<span class="op">(</span>wi<span class="op">);</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="matériel-de-feuil-et-de-capteur" class="level3">
<h3 class="anchored" data-anchor-id="matériel-de-feuil-et-de-capteur">2.1.3. Matériel de feuil et de capteur</h3>
<p>L’implémentation de ces deux matériaux est pareil que celle de matériel de transparence, sauf que l’ior (index of reflectance) de feuil est 1.425 et l’ior de capteur est 1.</p>
<p>L’article concernant l’ior de feuil: https://opg.optica.org/ao/abstract.cfm?uri=ao-13-1-109</p>
</section>
</section>
<section id="lumière" class="level2">
<h2 class="anchored" data-anchor-id="lumière">2.2. Lumière</h2>
<p style="text-align: center">
<img src="images/lumière.png" style="display:block; margin: auto;"> <br> Figure 8: Des types de source de la lumière
</p>
<p>Dans un moteur de rendu, il existe plusieurs types de sources de la lumière qui va nous donner des résultats différents de rendu en appliquant dans la scène. Afin de simuler ces types de lumière, on va échantillonner des rayons de lumière qui partent de ces sources. Chaque rayon de lumière peut être répresenté par ces facteurs:</p>
<ul>
<li>Le point de départ</li>
<li>La direction de la lumière</li>
<li>L’énergie lumineuse de ce rayon</li>
</ul>
<p>Ci-dessous, c’est l’implémentation de lumière en général. Il va contenir une variable pour stocker l’énergie totale de cette source en Watt, des fonctions pour générer le point de départ ainsi que la direction de rayon.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/light.hpp#L23C1-L37C3</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Light <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Light<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/**</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    * </span><span class="an">@fn</span><span class="co"> </span><span class="do">Vec3f</span><span class="co"> </span><span class="do">Le()</span><span class="co"> </span><span class="do">override</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    * Get the light emission of the light source.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    * </span><span class="an">@returns</span><span class="co"> the le attribute.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> Vec3f Le<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> SurfaceInfo samplePoint<span class="op">(</span>Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> Vec3f sampleDirection<span class="op">(</span><span class="at">const</span> SurfaceInfo <span class="op">&amp;</span>surfInfo<span class="op">,</span> Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> <span class="dt">float</span> <span class="op">&amp;</span>pdf<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Dans cette simulation, on a déjà implémenté 4 types de lumières correspondant à 4 stratégies d’échantillonage de lumière, ce sont:</p>
<ul>
<li>Point Light</li>
<li>Spot Light</li>
<li>Tube Light</li>
<li>Area Light</li>
</ul>
</section>
<section id="scène" class="level2">
<h2 class="anchored" data-anchor-id="scène">2.3. Scène</h2>
<p>La classe de la scène est la classe qui faire des liens entre tous les données de géometries, de matériaux et de lumière pour créer une simulation.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/scene.hpp#L151C1-L166C80</p>
<p>Les tableaux qui contiennent les données de géometries.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> vertices<span class="op">;</span>   <span class="co">///&lt; The vertices of the scene.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;</span> indices<span class="op">;</span> <span class="co">///&lt; The indices of the scene.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> normals<span class="op">;</span>    <span class="co">///&lt; The normals of the scene.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>Triangle<span class="op">&gt;</span> triangles<span class="op">;</span> <span class="co">///&lt; The triangles of the scene per face.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Le tableau qui contiennent les données de matériaux.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="ex">boost::</span>optional<span class="op">&lt;</span>tinyobj<span class="op">::</span><span class="dt">material_t</span><span class="op">&gt;&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>      materials<span class="op">;</span> <span class="co">///&lt; The materials of the scene.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Les tableaux qui contiennent les données de lumière ainsi le BxDF pour chaque triangle.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="ex">boost::</span>shared_ptr<span class="op">&lt;</span>BxDF<span class="op">&gt;&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>      bxdfs<span class="op">;</span> <span class="co">///&lt; The bxdfs of the scene per face.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="ex">boost::</span>shared_ptr<span class="op">&lt;</span>Light<span class="op">&gt;&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      lights<span class="op">;</span> <span class="co">///&lt; The lights of the scene per face.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span>Primitive<span class="op">&gt;</span> primitives<span class="op">;</span> <span class="co">///&lt; The primitives of the scene per face.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="ajouter-de-la-lumière-dans-la-scène" class="level3">
<h3 class="anchored" data-anchor-id="ajouter-de-la-lumière-dans-la-scène">2.3.1. Ajouter de la lumière dans la scène</h3>
<p>Ci-dessous, c’est la fonction d’ajouter un source de lumière dans la scène. Cependant, les variables <em>newVertices</em> et <em>newIndices</em> répresentent la forme de géometrie de source (un point, un cylinder, etc). L’intensité et la couleur répresentent l’énergie lumineuse en Watts et le longueur d’onde de la lumière.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/scene.hpp#L380C3-L426C4</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> addLight<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> newVertices<span class="op">,</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;</span> newIndices<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> newNormals<span class="op">,</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                <span class="dt">float</span> intensity<span class="op">,</span> Vec3f color<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> <span class="op">&amp;</span>i <span class="op">:</span> newIndices<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      i <span class="op">+=</span> nVertices<span class="op">();</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>vertices<span class="op">.</span>insert<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>vertices<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>newVertices<span class="op">),</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                          <span class="bu">std::</span>end<span class="op">(</span>newVertices<span class="op">));</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>indices<span class="op">.</span>insert<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>indices<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>newIndices<span class="op">),</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                         <span class="bu">std::</span>end<span class="op">(</span>newIndices<span class="op">));</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>normals<span class="op">.</span>insert<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>normals<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>newNormals<span class="op">),</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                         <span class="bu">std::</span>end<span class="op">(</span>newNormals<span class="op">));</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// populate  triangles</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> faceID <span class="op">=</span> nFaces<span class="op">()</span> <span class="op">-</span> <span class="op">(</span>newIndices<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">3</span><span class="op">);</span> faceID <span class="op">&lt;</span> nFaces<span class="op">();</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>         <span class="op">++</span>faceID<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      tinyobj<span class="op">::</span><span class="dt">material_t</span> m<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> color<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> color<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> color<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>ambient<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>ambient<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>ambient<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>emission<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> color<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span>intensity<span class="op">);</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>emission<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> color<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span>intensity<span class="op">);</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>emission<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> color<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span>intensity<span class="op">);</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>specular<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.00</span><span class="op">;</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>specular<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.00</span><span class="op">;</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>specular<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.00</span><span class="op">;</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>dissolve <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>illum <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>      <span class="kw">this</span><span class="op">-&gt;</span>materials<span class="op">.</span>emplace_back<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>      <span class="co">// populate BxDF</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> material <span class="op">=</span> <span class="kw">this</span><span class="op">-&gt;</span>materials<span class="op">[</span>faceID<span class="op">];</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>material<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>        tinyobj<span class="op">::</span><span class="dt">material_t</span> m <span class="op">=</span> material<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>bxdfs<span class="op">.</span>push_back<span class="op">(</span>createBxDF<span class="op">(</span>m<span class="op">));</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>      <span class="co">// default material</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>bxdfs<span class="op">.</span>push_back<span class="op">(</span>createDefaultBxDF<span class="op">());</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Après d’ajouter des sources de lumière par cette fonction, il faut d’appeler la fonction setupTriangles() pour qu’il puisse générer des <em>AreaLights</em> de ces sources. Chaque <em>AreaLight</em> va correspondre à un des triangles qui répresentent la forme de source de la lumière. D’autre part, cette fonction va stocker aussi les addresses des triangles, des lumières ainsi que des BXDF dans un dictionnaire, le tableau <em>primitives</em>. Cela va faciliter la recherche des données utilisées pour calculer la réflexion de la lumière dans les phases suivant.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/scene.hpp#L335C1-L368C4</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> setupTriangles<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// populate  triangles</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> faceID <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> faceID <span class="op">&lt;</span> nFaces<span class="op">();</span> <span class="op">++</span>faceID<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// add triangle</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">this</span><span class="op">-&gt;</span>triangles<span class="op">.</span>emplace_back<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>vertices<span class="op">.</span>data<span class="op">(),</span> <span class="kw">this</span><span class="op">-&gt;</span>indices<span class="op">.</span>data<span class="op">(),</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                                   <span class="kw">this</span><span class="op">-&gt;</span>normals<span class="op">.</span>data<span class="op">(),</span> faceID<span class="op">);</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// populate lights, primitives</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> faceID <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> faceID <span class="op">&lt;</span> nFaces<span class="op">();</span> <span class="op">++</span>faceID<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// add light</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>      <span class="ex">boost::</span>shared_ptr<span class="op">&lt;</span>Light<span class="op">&gt;</span> light <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> material <span class="op">=</span> <span class="kw">this</span><span class="op">-&gt;</span>materials<span class="op">[</span>faceID<span class="op">];</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>      <span class="co">// std::cout &lt;&lt; "material check" &lt;&lt; std::endl;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>material<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        tinyobj<span class="op">::</span><span class="dt">material_t</span> m <span class="op">=</span> material<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        light <span class="op">=</span> createAreaLight<span class="op">(</span>m<span class="op">,</span> <span class="op">&amp;</span><span class="kw">this</span><span class="op">-&gt;</span>triangles<span class="op">[</span>faceID<span class="op">]);</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>light <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>          lights<span class="op">.</span>push_back<span class="op">(</span>light<span class="op">);</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>      <span class="co">// add primitive</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">// std::cout &lt;&lt; "Adding primitives" &lt;&lt; std::endl;</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>      primitives<span class="op">.</span>emplace_back<span class="op">(&amp;</span><span class="kw">this</span><span class="op">-&gt;</span>triangles<span class="op">[</span>faceID<span class="op">],</span> <span class="kw">this</span><span class="op">-&gt;</span>bxdfs<span class="op">[</span>faceID<span class="op">],</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>                              light<span class="op">);</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::cout &lt;&lt; "Triangles setup! " &lt;&lt; std::endl;</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __OUTPUT__</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"[Scene] vertices: "</span> <span class="op">&lt;&lt;</span> nVertices<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"[Scene] faces: "</span> <span class="op">&lt;&lt;</span> nFaces<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"[Scene] lights: "</span> <span class="op">&lt;&lt;</span> lights<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="ajouter-des-autres-objets-dans-la-scène" class="level3">
<h3 class="anchored" data-anchor-id="ajouter-des-autres-objets-dans-la-scène">2.3.2. Ajouter des autres objets dans la scène</h3>
<p>Voici la fonction d’ajouter les autres objets que la lumière à la scène. Cependant, les variables <em>vertices</em> et <em>indices</em> sont répresenté la géometrie.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> addFaceInfosMat<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> vertices<span class="op">,</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                       <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;</span> indices<span class="op">,</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                       <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> normals<span class="op">,</span> Material mat<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> <span class="op">&amp;</span>i <span class="op">:</span> indices<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      i <span class="op">+=</span> nVertices<span class="op">();</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>vertices<span class="op">.</span>insert<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>vertices<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>vertices<span class="op">),</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                          <span class="bu">std::</span>end<span class="op">(</span>vertices<span class="op">));</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>indices<span class="op">.</span>insert<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>indices<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>indices<span class="op">),</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                         <span class="bu">std::</span>end<span class="op">(</span>indices<span class="op">));</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>normals<span class="op">.</span>insert<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>normals<span class="op">),</span> <span class="bu">std::</span>begin<span class="op">(</span>normals<span class="op">),</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                         <span class="bu">std::</span>end<span class="op">(</span>normals<span class="op">));</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// populate materials</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> faceID <span class="op">=</span> nFaces<span class="op">()</span> <span class="op">-</span> <span class="op">(</span>indices<span class="op">.</span>size<span class="op">()</span> <span class="op">/</span> <span class="dv">3</span><span class="op">);</span> faceID <span class="op">&lt;</span> nFaces<span class="op">();</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>         <span class="op">++</span>faceID<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>      tinyobj<span class="op">::</span><span class="dt">material_t</span> m<span class="op">;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>ambient<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>ambient<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>ambient<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>ambient<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>ambient<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>ambient<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>emission<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.00</span><span class="op">;</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>emission<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.00</span><span class="op">;</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>emission<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.00</span><span class="op">;</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>specular<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>specular<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>specular<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>specular<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>specular<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> mat<span class="op">.</span>specular<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>shininess <span class="op">=</span> mat<span class="op">.</span>shininess<span class="op">;</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>dissolve <span class="op">=</span> <span class="fl">1.0</span><span class="bu">f</span> <span class="op">-</span> mat<span class="op">.</span>transparency<span class="op">;</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>      m<span class="op">.</span>ior <span class="op">=</span> mat<span class="op">.</span>ior<span class="op">;</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>mat<span class="op">.</span>transparency <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>        m<span class="op">.</span>illum <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>        m<span class="op">.</span>illum <span class="op">=</span> mat<span class="op">.</span>illum<span class="op">;</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>      <span class="kw">this</span><span class="op">-&gt;</span>materials<span class="op">.</span>emplace_back<span class="op">(</span>m<span class="op">);</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>      <span class="co">// populate BxDF</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> material <span class="op">=</span> <span class="kw">this</span><span class="op">-&gt;</span>materials<span class="op">[</span>faceID<span class="op">];</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>material<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        tinyobj<span class="op">::</span><span class="dt">material_t</span> m <span class="op">=</span> material<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>bxdfs<span class="op">.</span>push_back<span class="op">(</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>            createBxDF<span class="op">(</span>m<span class="op">,</span> mat<span class="op">.</span>reflectance<span class="op">,</span> mat<span class="op">.</span>transmittance<span class="op">,</span> mat<span class="op">.</span>roughness<span class="op">));</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>      <span class="co">// default material</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>bxdfs<span class="op">.</span>push_back<span class="op">(</span>createDefaultBxDF<span class="op">());</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Dans ce code, après de stocker tous les vertices et triangles ainsi que le matériel dans la scène, on va générer un BxDF pour chaque triangle du maillage. Cela va nous aider à calculer la réflexion sur chaque triangle plus facile.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/scene.hpp#L32C1-L66C2</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">boost::</span>shared_ptr<span class="op">&lt;</span>BxDF<span class="op">&gt;</span> createBxDF<span class="op">(</span>tinyobj<span class="op">::</span><span class="dt">material_t</span> <span class="op">&amp;</span>material<span class="op">,</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">float</span> reflectance <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">float</span> transmittance <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">float</span> roughness <span class="op">=</span> <span class="fl">0.5</span><span class="bu">f</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> Vec3f kd <span class="op">=</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>      Vec3f<span class="op">(</span>material<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">0</span><span class="op">],</span> material<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">1</span><span class="op">],</span> material<span class="op">.</span>diffuse<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> Vec3f ks <span class="op">=</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>      Vec3f<span class="op">(</span>material<span class="op">.</span>specular<span class="op">[</span><span class="dv">0</span><span class="op">],</span> material<span class="op">.</span>specular<span class="op">[</span><span class="dv">1</span><span class="op">],</span> material<span class="op">.</span>specular<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>material<span class="op">.</span>illum <span class="op">==</span> <span class="dv">2</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>ks <span class="op">==</span> Vec3fZero<span class="op">))</span> <span class="op">{</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    material<span class="op">.</span>illum <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> <span class="op">(</span>material<span class="op">.</span>illum<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ex">boost::</span>make_shared<span class="op">&lt;</span>Mirror<span class="op">&gt;(</span>ks<span class="op">);</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// mirror</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ex">boost::</span>make_shared<span class="op">&lt;</span>Mirror<span class="op">&gt;(</span>Vec3f<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">));</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">6</span><span class="op">:</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// leaf</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    material<span class="op">.</span>ior <span class="op">=</span> <span class="fl">1.425</span><span class="bu">f</span><span class="op">;</span> <span class="co">// Source:</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// https://opg.optica.org/ao/abstract.cfm?uri=ao-13-1-109</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ex">boost::</span>make_shared<span class="op">&lt;</span>Leaf<span class="op">&gt;(</span>kd<span class="op">,</span> material<span class="op">.</span>ior<span class="op">,</span> roughness<span class="op">);</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">7</span><span class="op">:</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Transparent</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ex">boost::</span>make_shared<span class="op">&lt;</span>Transparent<span class="op">&gt;(</span>kd<span class="op">,</span> material<span class="op">.</span>ior<span class="op">);</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="dv">9</span><span class="op">:</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ex">boost::</span>make_shared<span class="op">&lt;</span>Refltr<span class="op">&gt;(</span>kd<span class="op">,</span> reflectance<span class="op">,</span> transmittance<span class="op">,</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>                                      roughness<span class="op">);</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">default</span><span class="op">:</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lambert</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ex">boost::</span>make_shared<span class="op">&lt;</span>Lambert<span class="op">&gt;(</span>kd<span class="op">);</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="calculer-dintersection" class="level3">
<h3 class="anchored" data-anchor-id="calculer-dintersection">2.3.3. Calculer d’intersection</h3>
<p>Afin de calculer l’intersection entre un rayon et tous les triangles dans la scène, on utilise la bibliothèque de Embree. En effet, d’abord, on construire un scène de Embree avec tous les tableux des données de géometrie et de matériel. Ensuite, on utilise la fonction <em>rtcIntersect1</em> de Embree pour obtenir la résultat de l’intersection.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/scene.hpp#L687C3-L721C4</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> build<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __OUTPUT__</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"[Scene] building scene..."</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// setup embree</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    device <span class="op">=</span> rtcNewDevice<span class="op">(</span><span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    scene <span class="op">=</span> rtcNewScene<span class="op">(</span>device<span class="op">);</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    rtcSetSceneBuildQuality<span class="op">(</span>scene<span class="op">,</span> RTC_BUILD_QUALITY_MEDIUM<span class="op">);</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    rtcSetSceneFlags<span class="op">(</span>scene<span class="op">,</span> RTC_SCENE_FLAG_ROBUST<span class="op">);</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    RTCGeometry geom <span class="op">=</span> rtcNewGeometry<span class="op">(</span>device<span class="op">,</span> RTC_GEOMETRY_TYPE_TRIANGLE<span class="op">);</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// set vertices</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> <span class="op">*</span>vb <span class="op">=</span> <span class="op">(</span><span class="dt">float</span> <span class="op">*)</span>rtcSetNewGeometryBuffer<span class="op">(</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        geom<span class="op">,</span> RTC_BUFFER_TYPE_VERTEX<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> RTC_FORMAT_FLOAT3<span class="op">,</span> <span class="dv">3</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">float</span><span class="op">),</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>        nVertices<span class="op">());</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> vertices<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>      vb<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> vertices<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// set indices</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> <span class="op">*</span>ib <span class="op">=</span> <span class="op">(</span><span class="dt">uint32_t</span> <span class="op">*)</span>rtcSetNewGeometryBuffer<span class="op">(</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>        geom<span class="op">,</span> RTC_BUFFER_TYPE_INDEX<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> RTC_FORMAT_UINT3<span class="op">,</span> <span class="dv">3</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">uint32_t</span><span class="op">),</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>        nFaces<span class="op">());</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> indices<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>      ib<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> indices<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    rtcCommitGeometry<span class="op">(</span>geom<span class="op">);</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    rtcAttachGeometry<span class="op">(</span>scene<span class="op">,</span> geom<span class="op">);</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    rtcReleaseGeometry<span class="op">(</span>geom<span class="op">);</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    rtcCommitScene<span class="op">(</span>scene<span class="op">);</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/scene.hpp#L730C1-L777C4</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> intersect<span class="op">(</span><span class="at">const</span> Ray <span class="op">&amp;</span>ray<span class="op">,</span> IntersectInfo <span class="op">&amp;</span>info<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    RTCRayHit rayhit<span class="op">{};</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>org_x <span class="op">=</span> ray<span class="op">.</span>origin<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>org_y <span class="op">=</span> ray<span class="op">.</span>origin<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>org_z <span class="op">=</span> ray<span class="op">.</span>origin<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>dir_x <span class="op">=</span> ray<span class="op">.</span>direction<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>dir_y <span class="op">=</span> ray<span class="op">.</span>direction<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>dir_z <span class="op">=</span> ray<span class="op">.</span>direction<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>tnear <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>tfar <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;::</span>infinity<span class="op">();</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>mask <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>ray<span class="op">.</span>flags <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>hit<span class="op">.</span>geomID <span class="op">=</span> RTC_INVALID_GEOMETRY_ID<span class="op">;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>hit<span class="op">.</span>instID<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> RTC_INVALID_GEOMETRY_ID<span class="op">;</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    rayhit<span class="op">.</span>hit<span class="op">.</span>instPrimID<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> RTC_INVALID_GEOMETRY_ID<span class="op">;</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    RTCRayQueryContext context<span class="op">;</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    rtcInitRayQueryContext<span class="op">(&amp;</span>context<span class="op">);</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    RTCIntersectArguments args<span class="op">;</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    rtcInitIntersectArguments<span class="op">(&amp;</span>args<span class="op">);</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    args<span class="op">.</span>context <span class="op">=</span> <span class="op">&amp;</span>context<span class="op">;</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    rtcIntersect1<span class="op">(</span>scene<span class="op">,</span> <span class="op">&amp;</span>rayhit<span class="op">,</span> <span class="op">&amp;</span>args<span class="op">);</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>rayhit<span class="op">.</span>hit<span class="op">.</span>geomID <span class="op">!=</span> RTC_INVALID_GEOMETRY_ID<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>      info<span class="op">.</span>t <span class="op">=</span> rayhit<span class="op">.</span>ray<span class="op">.</span>tfar<span class="op">;</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>      <span class="co">// get triangle shape</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> Triangle <span class="op">&amp;</span>tri <span class="op">=</span> <span class="kw">this</span><span class="op">-&gt;</span>triangles<span class="op">[</span>rayhit<span class="op">.</span>hit<span class="op">.</span>primID<span class="op">];</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>      <span class="co">// set surface info</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>      info<span class="op">.</span>surfaceInfo<span class="op">.</span>position <span class="op">=</span> ray<span class="op">(</span>info<span class="op">.</span>t<span class="op">);</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>      info<span class="op">.</span>surfaceInfo<span class="op">.</span>barycentric <span class="op">=</span> Vec2f<span class="op">(</span>rayhit<span class="op">.</span>hit<span class="op">.</span>u<span class="op">,</span> rayhit<span class="op">.</span>hit<span class="op">.</span>v<span class="op">);</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>      info<span class="op">.</span>surfaceInfo<span class="op">.</span>geometricNormal <span class="op">=</span> tri<span class="op">.</span>getGeometricNormal<span class="op">();</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>      info<span class="op">.</span>surfaceInfo<span class="op">.</span>shadingNormal <span class="op">=</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>          tri<span class="op">.</span>computeShadingNormal<span class="op">(</span>info<span class="op">.</span>surfaceInfo<span class="op">.</span>barycentric<span class="op">);</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>      orthonormalBasis<span class="op">(</span>info<span class="op">.</span>surfaceInfo<span class="op">.</span>shadingNormal<span class="op">,</span> info<span class="op">.</span>surfaceInfo<span class="op">.</span>dpdu<span class="op">,</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>                       info<span class="op">.</span>surfaceInfo<span class="op">.</span>dpdv<span class="op">);</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>      <span class="co">// set primitive</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>      info<span class="op">.</span>hitPrimitive <span class="op">=</span> <span class="op">&amp;</span><span class="kw">this</span><span class="op">-&gt;</span>primitives<span class="op">[</span>rayhit<span class="op">.</span>hit<span class="op">.</span>primID<span class="op">];</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="carte-de-photon" class="level2">
<h2 class="anchored" data-anchor-id="carte-de-photon">2.4. Carte de Photon</h2>
<p>Dans la carte de photon, chaque photon contiens l’énergie lumineuse en Watts, la position de photon, la direction de la lumière vers la surface et l’index du triangle contenant le photon.</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/photon_map.hpp#L15</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Photon <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    Vec3f throughput<span class="op">;</span>  <span class="co">///&lt; BxDF * Cos Term / pdf</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    Vec3f position<span class="op">;</span> <span class="co">///&lt; The position of the photon in the scene</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    Vec3f wi<span class="op">;</span>  <span class="co">///&lt;  incident direction</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> triId <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">///&lt;  id of the triangle on which the photon ended up</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>La carte de photon peut être stocker sous la forme d’un KdTree ou un tableau.</p>
</section>
<section id="photon-tracing-1" class="level2">
<h2 class="anchored" data-anchor-id="photon-tracing-1">2.5. Photon Tracing</h2>
<p>Le pseudocode de la phase de Photon Tracing:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  nb_sample <span class="op">=</span> <span class="dv">10000000</span><span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  maxDepth <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> l<span class="op">:</span> <span class="dv">0</span> <span class="op">-&gt;</span> nb_light<span class="op">:</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s<span class="op">:</span> <span class="dv">0</span> <span class="op">-&gt;</span> nb_sample<span class="op">/</span>nb_light<span class="op">:</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>      <span class="pp">#</span><span class="er">Échantionner un rayon de lumière</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> k<span class="op">:</span> <span class="dv">0</span> <span class="op">-&gt;</span> maxDepth<span class="op">:</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#</span><span class="er">Calculer l'intersection entre le rayon et des triangles de la scène </span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> le rayon intersect un matériel de type Diffuse<span class="op">:</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>          <span class="pp">#</span><span class="er">Ajouter un photon à la carte de photon</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> le test de propabilité de Russian Roulette est réussit<span class="op">:</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            <span class="pp">#</span><span class="er">Terminer algo</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#</span><span class="er">Calculer le rayon de réflexion suivant</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Échantionnage un rayon de lumière</strong></p>
<p>Pour cette étape, on va choisir aléatoirement un source de la lumière dans la scène, un point de la surface de cette source et une direction. Ensuite, on va calculer l’énergie lumineuse avec l’équation dans la <em>section 1.2.1</em>.</p>
<p><span class="math display">\[ \phi = \frac{L(x \rightarrow \omega) |cos(\vec{N_x}, \omega)|}{Np(x,\omega)} \]</span></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// sample initial ray from light and compute initial throughput</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> Ray sampleRayFromLight<span class="op">(</span><span class="at">const</span> Scene <span class="op">&amp;</span>scene<span class="op">,</span> Sampler <span class="op">&amp;</span>sampler<span class="op">,</span> Vec3f <span class="op">&amp;</span>throughput<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sample light</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> light_choose_pdf<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">boost::</span>shared_ptr<span class="op">&lt;</span>Light<span class="op">&gt;</span> light <span class="op">=</span> scene<span class="op">.</span>sampleLight<span class="op">(</span>sampler<span class="op">,</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                light_choose_pdf<span class="op">);</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sample point on light</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> light_pos_pdf<span class="op">;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    SurfaceInfo light_surf <span class="op">=</span> light<span class="op">-&gt;</span>samplePoint<span class="op">(</span>sampler<span class="op">,</span> light_pos_pdf<span class="op">);</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sample direction on light</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> light_dir_pdf<span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    Vec3f dir <span class="op">=</span> light<span class="op">-&gt;</span>sampleDirection<span class="op">(</span>light_surf<span class="op">,</span> sampler<span class="op">,</span> light_dir_pdf<span class="op">);</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// spawn ray</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    Ray ray<span class="op">(</span>light_surf<span class="op">.</span>position<span class="op">,</span> dir<span class="op">);</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    Vec3f le <span class="op">=</span> light<span class="op">-&gt;</span>Le<span class="op">();</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    throughput <span class="op">=</span> le <span class="op">/</span> <span class="op">(</span>light_choose_pdf <span class="op">*</span> light_pos_pdf <span class="op">*</span> light_dir_pdf<span class="op">)</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span> <span class="bu">std::</span>abs<span class="op">(</span>dot<span class="op">(</span>dir<span class="op">,</span> light_surf<span class="op">.</span>shadingNormal<span class="op">));</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ray<span class="op">;</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Le test de propabilité de Russian Roulette</strong></p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/integrator.hpp#L499C8-L507C44</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>k <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span>  </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">float</span> russian_roulette_prob <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>max<span class="op">(</span>throughput<span class="op">[</span><span class="dv">0</span><span class="op">],</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>max<span class="op">(</span>throughput<span class="op">[</span><span class="dv">1</span><span class="op">],</span> throughput<span class="op">[</span><span class="dv">2</span><span class="op">])),</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>sampler_per_thread<span class="op">.</span>getNext1D<span class="op">()</span> <span class="op">&gt;=</span> russian_roulette_prob<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  throughput <span class="op">/=</span> russian_roulette_prob<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Il y a un remarque sur cette implémentation de Russian Roulette. C’est que la probabilité de Russian Roulette est toujour égale 1 si l’énergie lumineuse de rayon (throughput) est supérieur de 1. C’est-à-dire que cette partie de Russian Roulette n’influence pas la calcul de lumière jusqu’à le temps où l’énergie lumineuse est très petite (inférieur de 1).</p>
<p><strong>Calculer le rayon de réflexion suivant</strong></p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/integrator.hpp#L510C7-L525C49</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// sample direction by BxDF</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>Vec3f dir<span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> pdf_dir<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Vec3f f <span class="op">=</span> info<span class="op">.</span>hitPrimitive<span class="op">-&gt;</span>sampleBxDF<span class="op">(</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span>ray<span class="op">.</span>direction<span class="op">,</span> info<span class="op">.</span>surfaceInfo<span class="op">,</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        TransportDirection<span class="op">::</span>FROM_LIGHT<span class="op">,</span> sampler_per_thread<span class="op">,</span> dir<span class="op">,</span> pdf_dir<span class="op">);</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">// update throughput and ray</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!</span>is_captor<span class="op">)</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    throughput <span class="op">*=</span> f</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span> cosTerm<span class="op">(-</span>ray<span class="op">.</span>direction<span class="op">,</span> dir<span class="op">,</span> info<span class="op">.</span>surfaceInfo<span class="op">,</span> TransportDirection<span class="op">::</span>FROM_LIGHT<span class="op">)</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">/</span> pdf_dir<span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>ray <span class="op">=</span> Ray<span class="op">(</span>info<span class="op">.</span>surfaceInfo<span class="op">.</span>position<span class="op">,</span> dir<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="photon-collecting-1" class="level2">
<h2 class="anchored" data-anchor-id="photon-collecting-1">2.6. Photon Collecting</h2>
<p>Dans cette phase, pour chaque pixel de l’image, on va lancer un rayon qui part de la caméra et calculer le point de contact avec la scène. Ensuite, il faut de chercher un nombre de photons qui sont proche de ce point pour estimer l’énergie lumineuse émise en ce point. Cette valeur de l’énergie lumineuse correspond la couleur du pixel d’image.</p>
<p><span class="math display">\[ I = \frac{1}{A}\sum_{p_i \in S }\phi_i\]</span></p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/src/cpp/include/integrator.hpp#L78C1-L97C3</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compute reflected radiance with global photon map</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    Vec3f computeRadianceWithPhotonMap<span class="op">(</span><span class="at">const</span> Vec3f <span class="op">&amp;</span>wo<span class="op">,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>            IntersectInfo <span class="op">&amp;</span>info<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// get nearby photons</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> max_dist2<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> photon_indices <span class="op">=</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>                globalPhotonMap<span class="op">.</span>queryKNearestPhotons<span class="op">(</span>info<span class="op">.</span>surfaceInfo<span class="op">.</span>position<span class="op">,</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>                        nEstimationGlobal<span class="op">,</span> max_dist2<span class="op">);</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        Vec3f Lo<span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="dt">int</span> photon_idx <span class="op">:</span> photon_indices<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> Photon <span class="op">&amp;</span>photon <span class="op">=</span> globalPhotonMap<span class="op">.</span>getIthPhoton<span class="op">(</span>photon_idx<span class="op">);</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> Vec3f f <span class="op">=</span> info<span class="op">.</span>hitPrimitive<span class="op">-&gt;</span>evaluateBxDF<span class="op">(</span>wo<span class="op">,</span> photon<span class="op">.</span>wi<span class="op">,</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>                    info<span class="op">.</span>surfaceInfo<span class="op">,</span> TransportDirection<span class="op">::</span>FROM_CAMERA<span class="op">);</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>            Lo <span class="op">+=</span> f <span class="op">*</span> photon<span class="op">.</span>throughput<span class="op">;</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>photon_indices<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            Lo <span class="op">/=</span> <span class="op">(</span>nPhotonsGlobal <span class="op">*</span> PI <span class="op">*</span> max_dist2<span class="op">);</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Lo<span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="la-programme-principal" class="level2">
<h2 class="anchored" data-anchor-id="la-programme-principal">2.7. La programme principal</h2>
<p>Pour s’adapter au serveur MorphoNet, on exportit tous les codes C++ des parties avant à un bibliothèque Python avec un wrapper Python. Ci-dessous, c’est les codes à construire la simulation d’interception de lumière dans la chambre de culture. (plantglRadScene)</p>
<p>https://github.com/AurelienBesnier/photon_mapping/blob/main/examples/python/plantgl-rad-scene/planglRadScene.py#L1124C1-L1151C52</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">ajouter des objets à la scène</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>materialsR<span class="op">,</span> materialsT <span class="op">=</span> setup_dataset_materials<span class="op">(</span>w<span class="op">)</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>scene<span class="op">.</span>clear<span class="op">()</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>captor_dict <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sh in sc<span class="op">:</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    add_shape<span class="op">(</span>scene<span class="op">,</span> sh<span class="op">,</span> w<span class="op">,</span> materialsR<span class="op">,</span> materialsT<span class="op">)</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>tr2shmap <span class="op">=</span> <span class="op">{}</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>addCaptors<span class="op">(</span>scene<span class="op">,</span> captor_dict<span class="op">,</span> <span class="st">"captors/captors_expe1.csv"</span><span class="op">)</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>scene<span class="op">.</span>setupTriangles<span class="op">()</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">initialiser la scène de Embree</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>scene<span class="op">.</span>build<span class="op">()</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">initialiser le photon mapping</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">"Building photonMap..."</span><span class="op">)</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>integrator <span class="op">=</span> PhotonMapping<span class="op">(</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    n_photons<span class="op">,</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    n_estimation_global<span class="op">,</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    n_photons_caustics_multiplier<span class="op">,</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    n_estimation_caustics<span class="op">,</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    final_gathering_depth<span class="op">,</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    max_depth<span class="op">,</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="pp">#</span><span class="er">construire la carte de photon</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>sampler <span class="op">=</span> UniformSampler<span class="op">(</span>random<span class="op">.</span>randint<span class="op">(</span><span class="dv">1</span><span class="op">,</span> sys<span class="op">.</span>maxsize<span class="op">))</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>integrator<span class="op">.</span>build<span class="op">(</span>scene<span class="op">,</span> sampler<span class="op">,</span> False<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="reférences" class="level1">
<h1>Reférences</h1>
<ul>
<li>[1] Bernard Péroche, Dominique Bechmann. Informatique garaphique et rendu. Lavoisier, 2007.</li>
<li>[2] Schill, Steven &amp; Jensen, John &amp; Raber, George &amp; Porter, Dwayne. (2004). Temporal Modeling of Bidirectional Reflection Distribution Function (BRDF) in Coastal Vegetation. GIScience &amp; Remote Sensing. 41. 116-135. 10.2747/1548-1603.41.2.116.</li>
<li>[3] https://opg.optica.org/ao/abstract.cfm?uri=ao-13-1-109</li>
<li>[4] Lewis, Robert. (2001). Making Shaders More Physically Plausible. Computer Graphics Forum. 13. 10.1111/1467-8659.1320109.</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>